# MySQL 锁类型

按粒度分类可分成全局锁、表级锁、行级锁，后两者是重点。  
按锁功能分类，可分为共享锁（Share Lock，S锁）和排它锁（Exclusive Lock，X锁）

## 共享锁&排它锁

事务在读取记录的时候获取 S 锁，允许多个事务同时获取 S 锁，相互之间不会冲突。

```sql
SELECT ... LOCK IN SHARE MODE
```

事务在修改记录的时候获取 X 锁，且只允许一个事务获取 X 锁，其他事务需要阻塞等待。

```sql
SELECT ... FOR UPDATE
```

|冲突|S|X|
|--|--|--|
|S|不冲突|冲突|
|X|冲突|冲突|

## 意向锁（表锁）

InnoDB 加表锁的时候，如何判断里面有行锁，这时便有了意向锁。  
有共享意向锁（IS锁）和独占意向锁（IX锁）。

|冲突|S|X|IS|IX|
|--|--|--|--|--|
|S|不冲突|冲突|不冲突|冲突|
|X|冲突|冲突|冲突|冲突|
|IS|不冲突|冲突|不冲突|不冲突|
|IX|冲突|冲突|不冲突|不冲突|

## 记录锁&间隙锁&临键锁（行锁）

### 记录锁

锁定索引记录，作用于索引。  
如事务A执行 `SELECT * FROM t1 WHERE name = 'xx' FOR UPDATE;` 那么 name = xx 这条记录就被锁定了，其他事务不能对这条记录进行插入、删除、修改。  
此时事务A未提交，事务B执行 `insert into t1 (name) values('xx')`会被阻塞，要是执行 `insert into t1 (name) values('aa')` 呢？

#### 场景一：name 列上有唯一索引

如果 name 列上有唯一索引：

事务 A 的 SELECT FOR UPDATE 只会锁定 name='xx' 的单行记录或该位置的间隙
事务 B 插入 name='aa' 的记录通常不会被阻塞，因为它操作的是索引中的不同位置

#### 场景二：name 列上有普通非唯一索引，采用 REPEATABLE READ （可重复读）隔离级别（MySQL 默认）

在这种情况下：

事务 A 会获取 next-key lock（记录锁+间隙锁）
是否阻塞取决于 'aa' 和 'xx' 在索引中的相对位置：
如果 'aa' 和 'xx' 在不同的间隙中，插入 'aa' 不会被阻塞
如果 'aa' 和 'xx' 在同一个间隙中，插入 'aa' 会被阻塞

#### 场景三：name 列上没有索引

如果 name 列上没有索引：

事务 A 的查询会导致表锁或全表扫描后的大范围记录锁
事务 B 插入任何记录（包括 name='aa'）很可能被阻塞

### 间隙锁&临键锁

防止幻读，锁定具体行和前面的间隙。

### 插入意向锁

### Auto-Inc Lock
